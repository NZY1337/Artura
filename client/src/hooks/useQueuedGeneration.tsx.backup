import { QueryClient } from "@tanstack/react-query";
import type { EditableProjectProps, ProjectResponseProps } from "../types";

type GridCell = {
  project: ProjectResponseProps["project"];
  images: ProjectResponseProps["images"];
  imageGenerationResponse: ProjectResponseProps["imageGenerationResponse"];
  loading?: boolean;
} | null;QueryClient } from "@tanstack/react-query";
import { EditableProjectProps, ProjectResponseProps } from "../types";

type GridCell = {
  project: any;
  images: any[];
  imageGenerationResponse: any;
  loading?: boolean;
};

type MutateFn = (
  project: EditableProjectProps,
  options?: {
    onSuccess?: (data: ProjectResponseProps) => void;
    onError?: () => void;
  }
) => void;

// Mock data generator
const generateMockResponse = (project: EditableProjectProps): ProjectResponseProps => {
  const mockId = `mock-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const imageId = `img-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  
  return {
    project: {
      id: mockId,
      userId: "mock-user-id",
      category: project.category!,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      prompt: project.prompt!,
      background: project.background || "auto",
      images: [],
      outputFormat: project.outputFormat!,
      quality: project.quality!,
      size: project.size!,
      designTheme: project.designTheme!,
      spaceType: project.spaceType!,
      n: project.n!,
    },
    images: [
      {
        id: imageId,
        url: "https://picsum.photos/800/600?random=" + Math.floor(Math.random() * 1000),
        createdAt: new Date().toISOString(),
        projectId: mockId,
      }
    ],
    imageGenerationResponse: {
      id: `resp-${Date.now()}`,
      projectId: mockId,
      inputTokens: Math.floor(Math.random() * 1000) + 500,
      imageTokens: Math.floor(Math.random() * 500) + 200,
      textTokens: Math.floor(Math.random() * 200) + 100,
      outputTokens: Math.floor(Math.random() * 100) + 50,
      totalTokens: Math.floor(Math.random() * 1500) + 800,
      imageCost: Math.random() * 2 + 0.5,
      tokenCost: Math.random() * 1 + 0.2,
      totalCost: Math.random() * 3 + 0.7,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    }
  };
};

export default function useQueuedGeneration({
  setGrid,
  mutateGenerator,
  mutateEditor,
  queryClient,
  notifications,
  useMockData = true, // Add this flag to enable/disable mocking
}: {
  setGrid: (updater: (prev: GridCell[]) => GridCell[]) => void;
  mutateGenerator: MutateFn;
  mutateEditor: MutateFn;
  queryClient: QueryClient;
  notifications: { show: (s: string, opts?: Record<string, unknown> | undefined) => void };
  useMockData?: boolean; // Make it optional with default true
}) {
  const handleQueuedGeneration = async (project: EditableProjectProps) => {
    let targetIndex: number | null = null;
    const { category } = project;

    if (project.prompt === "") {
      notifications.show("Add more details to the prompt for better results.", {
        severity: "error",
        autoHideDuration: 3000,
      });
      return;
    }

    setGrid((prevGrid: GridCell[]) => {
      const newGrid = [...prevGrid];
      const firstEmptyIndex = newGrid.findIndex((cell) => cell == null);
      if (firstEmptyIndex !== -1) {
        newGrid[firstEmptyIndex] = { loading: true } as unknown as GridCell;
        targetIndex = firstEmptyIndex;
      }

      return newGrid;
    });

    if (targetIndex === null) return;

    // If using mock data, simulate API call with mock response
    if (useMockData) {
      // Simulate API delay
      setTimeout(() => {
        const mockData = generateMockResponse(project);
        
        setGrid((prevGrid: GridCell[]) => {
          const newGrid = [...prevGrid];
          newGrid[targetIndex!] = mapResponseData(mockData);
          return newGrid;
        });

        queryClient.invalidateQueries({ queryKey: ["projects"] });
        
        notifications.show(`Mock ${category === "DESIGN_EDITOR" ? "editing" : "generation"} completed!`, {
          severity: "success",
          autoHideDuration: 3000,
        });
      }, 2000 + Math.random() * 3000); // Random delay between 2-5 seconds to simulate real API
      
      return;
    }

    if (category === "DESIGN_EDITOR") {
      mutateEditor(project, {
        onSuccess: (data: ProjectResponseProps) => {
          setGrid((prevGrid: GridCell[]) => {
            const newGrid = [...prevGrid];
            newGrid[targetIndex!] = mapResponseData(data);
            return newGrid;
          });

          queryClient.invalidateQueries({ queryKey: ["projects"] });
        },
        onError: () => {
          setGrid((prevGrid: GridCell[]) => {
            const newGrid = [...prevGrid];
            newGrid[targetIndex!] = null;
            return newGrid;
          });
        },
      });
    }

    if (category === "DESIGN_GENERATOR") {
      mutateGenerator(project, {
        onSuccess: (data: ProjectResponseProps) => {
          setGrid((prevGrid: GridCell[]) => {
            const newGrid = [...prevGrid];
            newGrid[targetIndex!] = mapResponseData(data);
            return newGrid;
          });

          queryClient.invalidateQueries({ queryKey: ["projects"] });
        },
        onError: () => {
          setGrid((prevGrid: GridCell[]) => {
            const newGrid = [...prevGrid];
            newGrid[targetIndex!] = null;
            return newGrid;
          });
        },
      });
    }
  };

  // Helper function to map response data to grid cell format
  const mapResponseData = (data: ProjectResponseProps): GridCell => {
    return {
      project: data.project,
      images: data.images,
      imageGenerationResponse: data.imageGenerationResponse || null,
      loading: false,
    };
  };

  return { handleQueuedGeneration };
}
